! Copyright (C) 2020 Bolding & Bruggeman and Hans Burchard

!> @note
!> array indices!!!!!
!> @endnote

!#define _AUTOMATIC_

!KB MODULE _MODULE_NAME_

!---------------------------------------------------------------------------

!KB CONTAINS

!---------------------------------------------------------------------------

SUBROUTINE _U_SUB_NAME_(imin,imax,jmin,jmax,umask,dxu,dyu,hu,u,tmask,iA,dt,h,f)

   USE, INTRINSIC :: ISO_FORTRAN_ENV

   IMPLICIT NONE

   ! Subroutine arguments
   integer, intent(in) :: imin,imax,jmin,jmax
   integer, intent(in) :: umask(imin-1:imax+1,jmin-1:jmax+1)
   real(real64), intent(in) :: dxu(imin-1:imax+1,jmin-1:jmax+1), dyu(imin-1:imax+1,jmin-1:jmax+1), hu(imin-1:imax+1,jmin-1:jmax+1), u(imin-1:imax+1,jmin-1:jmax+1)
   integer, intent(in) :: tmask(imin-1:imax+1,jmin-1:jmax+1)
   real(real64), intent(in) :: iA(imin-1:imax+1,jmin-1:jmax+1)
   real(real64), intent(in) :: dt
   real(real64), intent(inout) :: h(imin-1:imax+1,jmin-1:jmax+1), f(imin-1:imax+1,jmin-1:jmax+1)

!  Local constants

!  Local variables
#ifdef _AUTOMATIC_
   real(real64) :: flux(imin-1:imax,jmin:jmax)
   real(real64) :: QU(imin-1:imax,jmin:jmax)
#else
   real(real64), allocatable :: flux(:,:), QU(:,:)
#endif
   real(real64) :: cfl, fu, fuu, fd, hfo, advn
   real(real64) :: deltaf, deltafu, ratio
   real(real64) :: limiter
   integer :: i, j
!KB   integer :: scheme=1
!---------------------------------------------------------------------------
#ifndef _AUTOMATIC_
   allocate(flux(imin-1:imax,jmin:jmax), QU(imin-1:imax,jmin:jmax))
#endif

   ! the provided velocity MUST be ZERO at land!
   QU(imin-1,:) = 0 ! assume staggered u-fields [imin:imax]
   flux(imin-1:imax,:) = 0._real64

!  TODO: (vertical) interation!!!
   do j=jmin,jmax
!KB      do i=imin,imax-1
      do i=imin,imax
         QU(i,j) = u(i,j) * hu(i,j) * dyu(i,j)
         if (umask(i,j) == 1 .or. umask(i,j) == 2) then
            cfl = abs(u(i,j)*dt/dxu(i,j))
            if (u(i,j) .gt. 0) then
               fu  = f(i,j)
               fuu = fu
!               if (i > imin) then
                  if (umask(i-1,j) == 1 .or. umask(i-1,j) == 2) fuu = f(i-1,j)
!               end if
               fd = f(i+1,j)
            else
               fu  = f(i+1,j)
               fuu = fu
!               if (i < imax-1) then
                  if (umask(i+1,j) == 1 .or. umask(i+1,j) == 2) fuu = f(i+2,j)
!               end if
               fd = f(i,j)
            end if

            deltaf  = fd - fu
            deltafu = fu - fuu
            if (deltaf*deltafu .gt. 0) then
               ratio = deltafu / deltaf   ! slope ratio
#include "limiters.h"
               fu = fu + 0.5*limiter*(1-cfl)*deltaf
            end if
            flux(i,j) = QU(i,j)*fu
         else
            flux(i,j) = 0._real64
         end if
      end do
   end do

   do j=jmin,jmax
      do i=imin,imax
         if (tmask(i,j) == 1) then
            hfo = h(i,j)*f(i,j)
            h(i,j) = h(i,j) - dt*( QU(i,j)-QU(i-1,j) )*iA(i,j)
            advn = ( flux(i,j)-flux(i-1,j) )*iA(i,j)
            f(i,j) = ( hfo - dt*advn ) / h(i,j)
         end if
      end do
   end do

!#ifndef _AUTOMATIC_
!   deallocate(flux, QU)
!#endif
   return
END SUBROUTINE _U_SUB_NAME_

SUBROUTINE _V_SUB_NAME_(imin,imax,jmin,jmax,vmask,dxv,dyv,hv,v,tmask,iA,dt,h,f)
   USE, INTRINSIC :: ISO_FORTRAN_ENV

   IMPLICIT NONE

   ! Subroutine arguments
   integer, intent(in) :: imin,imax,jmin,jmax
   integer, intent(in) :: vmask(imin-1:imax+1,jmin-1:jmax+1)
   real(real64), intent(in) :: dxv(imin-1:imax+1,jmin-1:jmax+1), dyv(imin-1:imax+1,jmin-1:jmax+1), hv(imin-1:imax+1,jmin-1:jmax+1), v(imin-1:imax+1,jmin-1:jmax+1)
   integer, intent(in) :: tmask(imin-1:imax+1,jmin-1:jmax+1)
   real(real64), intent(in) :: iA(imin-1:imax+1,jmin-1:jmax+1)
   real(real64), intent(in) :: dt
   real(real64), intent(inout) :: h(imin-1:imax+1,jmin-1:jmax+1), f(imin-1:imax+1,jmin-1:jmax+1)

!  Local constants

!  Local variables
#ifdef _AUTOMATIC_
   real(real64) :: flux(imin:imax,jmin-1:jmax)
   real(real64) :: QV(imin:imax,jmin-1:jmax)
#else
   real(real64), allocatable :: flux(:,:), QV(:,:)
#endif
   real(real64) :: cfl, fu, fuu, fd, hfo, advn
   real(real64) :: deltaf, deltafu, ratio
   real(real64) :: limiter
   integer :: i, j
!KB   integer :: scheme=1
!---------------------------------------------------------------------------
#ifndef _AUTOMATIC_
   allocate(flux(imin:imax,jmin-1:jmax), QV(imin:imax,jmin-1:jmax))
#endif

   ! the provided velocity MUST be ZERO at land!
   QV(:,jmin-1) = 0 ! assume staggered u-fields [imin:imax]
   flux(:,jmin-1:jmax) = 0._real64

!  TODO: (vertical) interation!!!
   do j=jmin,jmax
!KB   do j=jmin,jmax-1
      do i=imin,imax
         QV(i,j) = v(i,j) * hv(i,j) * dxv(i,j)
         if (vmask(i,j) == 1 .or. vmask(i,j) == 2) then
            cfl = abs(v(i,j)*dt/dyv(i,j))
            if (v(i,j) .gt. 0) then
               fu  = f(i,j)
               fuu = fu
!               if (j > jmin) then
                  if (vmask(i,j-1) == 1 .or. vmask(i,j-1) == 2) fuu = f(i,j-1)
!               end if
               fd = f(i,j+1)
            else
               fu  = f(i,j+1)
               fuu = fu
!               if (j < jmax-1) then
                  if (vmask(i,j+1) == 1 .or. vmask(i,j+1) == 2) fuu = f(i,j+2)
!               end if
               fd = f(i,j)
            end if

            deltaf  = fd - fu
            deltafu = fu - fuu
            if (deltaf*deltafu .gt. 0) then
               ratio = deltafu / deltaf   ! slope ratio
#include "limiters.h"
               fu = fu + 0.5*limiter*(1-cfl)*deltaf
            end if
            flux(i,j) = QV(i,j)*fu
         else
            flux(i,j) = 0._real64
         end if
      end do
   end do

   do j=jmin,jmax
      do i=imin,imax
         if (tmask(i,j) == 1) then
            hfo = h(i,j)*f(i,j)
            h(i,j) = h(i,j) - dt*( QV(i,j)-QV(i,j-1) )*iA(i,j)
            advn = ( flux(i,j)-flux(i,j-1) )*iA(i,j)
            f(i,j) = ( hfo - dt*advn ) / h(i,j)
         end if
      end do
   end do

!#ifndef _AUTOMATIC_
!   deallocate(flux, QV)
!#endif
   return
END SUBROUTINE _V_SUB_NAME_

!SUBROUTINE _W_SUB_NAME_(imin,imax,jmin,jmax,dxu,dyu,hu,w,iA,dt,h,f)
SUBROUTINE _W_SUB_NAME_()
END SUBROUTINE _W_SUB_NAME_

!KB END MODULE _MODULE_NAME_

