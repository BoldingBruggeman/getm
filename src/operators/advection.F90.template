! Copyright (C) 2020 Bolding & Bruggeman and Hans Burchard

SUBROUTINE _U_SUB_NAME_(imin,imax,jmin,jmax,umask,dxu,dyu,hu,u,tmask,A,dt,h,f)

   USE, INTRINSIC :: ISO_FORTRAN_ENV

   IMPLICIT NONE

   ! Subroutine arguments
   integer, intent(in) :: imin,imax,jmin,jmax
   integer, intent(in) :: umask(:,:)
   real(real64), intent(in) :: dxu(:,:), dyu(:,:), hu(:,:), u(:,:)
   integer, intent(in) :: tmask(:,:)
   real(real64), intent(in) :: A(:,:)
   real(real64), intent(in) :: dt
   real(real64), intent(inout) :: h(:,:), f(:,:)

!  Local constants
   integer, parameter :: scheme=12

!  Local variables
#ifdef _AUTOMATIC_
   real(real64) :: flux(imin:imax,jmin:jmax)
   real(real64) :: QU(imin:imax,jmin:jmax)
#else
   real(real64), allocatable :: flux(:,:), QU(:,:)
#endif
   real(real64) :: cfl, fu, fuu, fd, hfo, advn
   real(real64) :: deltaf, deltafu, ratio
   real(real64) :: limiter
   integer :: i, j
!---------------------------------------------------------------------------

#ifndef _AUTOMATIC_
   allocate(flux(imin:imax,jmin:jmax), QU(imin:imax,jmin:jmax))
#endif

   ! the provided velocity MUST be ZERO at land!
   QU(imin-1,:) = 0 ! assume staggered u-fields [imin:imax]
!KB   self%QU  (imin:imax,:) = u(:,:) * hu(:,:) * dyu(:,:) ! to KK - why not in the main loops?
   flux(imin-1:imax,:) = 0

!  TODO: (vertical) interation!!!
   do j=jmin,jmax
      do i=imin,imax-1
         if (umask(i,j) == 1 .or. umask(i,j) == 2) then
            cfl = abs(u(i,j)*dt/dxu(i,j))
            if (u(i,j) .gt. 0) then
               fu  = f(i,j)
               fuu = fu
               if (i > imin) then
                  if (umask(i-1,j) == 1 .or. umask(i-1,j) == 2) fuu = f(i-1,j)
               end if
               fd = f(i+1,j)
            else
               fu  = f(i+1,j)
               fuu = fu
               if (i < imax-1) then
                  if (umask(i+1,j) == 1 .or. umask(i+1,j) == 2) fuu = f(i+2,j)
               end if
               fd = f(i,j)
            end if
!#if _SCHEME_ != UPSTREAM
            deltaf  = fd - fu
            deltafu = fu - fuu
            if (deltaf*deltafu .gt. 0) then
               ratio = deltafu / deltaf   ! slope ratio
               _LIMITER1_
               _LIMITER2_
               _LIMITER3_
               _LIMITER4_
               fu = fu + 0.5*limiter*(1-cfl)*deltaf
            end if
!#endif
            QU(i,j) = u(i,j) * hu(i,j) * dyu(i,j) ! to KK - here instead?
            flux(i,j) = QU(i,j)*fu
         end if
      end do
   end do

   do j=jmin,jmax
      do i=imin,imax
         if (tmask(i,j) == 1) then
            hfo = h(i,j)*f(i,j)
            h(i,j) = h(i,j) - dt*( QU(i,j)-QU(i-1,j) )*A(i,j) !KB
            advn = ( flux(i,j)-flux(i-1,j) )*A(i,j) !KB
            f(i,j) = ( hfo - dt*advn ) / h(i,j)
         end if
      end do
   end do

#ifndef _AUTOMATIC_
   deallocate(flux, QU)
#endif
   return
END SUBROUTINE _U_SUB_NAME_

SUBROUTINE _V_SUB_NAME_(imin,imax,jmin,jmax,dxu,dyu,hu,u,A,dt,h,f)
END SUBROUTINE _V_SUB_NAME_

SUBROUTINE _W_SUB_NAME_(imin,imax,jmin,jmax,dxu,dyu,hu,u,A,dt,h,f)
END SUBROUTINE _W_SUB_NAME_


#if 0
!---------------------------------------------------------------------------

PURE real(real64) FUNCTION adv_reconstruct(scheme,cfl,fuu,fu,fd)

   IMPLICIT NONE

   integer,intent(in)  :: scheme
   real(real64),intent(in) :: cfl,fuu,fu,fd
!
! !DEFINED PARAMETERS:
   integer, parameter :: SUPERBEE=4, P2_PDM=6, SPLMAX13=13, HSIMT=12, MUSCL=5
   real(real64),parameter :: one3rd = 1.0_real64 / 3
   real(real64),parameter :: one6th = 1.0_real64 / 6
! !LOCAL VARIABLES:
   real(real64)           :: ratio,limiter,kappa,x,deltaf,deltafu
!
!---------------------------------------------------------------------------

   adv_reconstruct = fu

   deltaf  = fd - fu
   deltafu = fu - fuu

   if (deltaf*deltafu .gt. 0) then

      ratio = deltafu / deltaf   ! slope ratio

      select case (scheme)
         case (SUPERBEE)
            limiter = MAX( MIN( 2*ratio , 1.0_real64 ) , MIN( ratio , 2.0_real64 ) )
         case (P2_PDM)
            x = one6th*(1-2*cfl)
            limiter = (0.5+x) + (0.5-x)*ratio
            limiter = MIN( 2*ratio/(cfl+1.d-10) , limiter , 2/(1-cfl) )
         case (SPLMAX13)
            limiter = MIN( 2*ratio , one3rd*MAX( 1+2*ratio , 2+ratio ) , 2.0_real64 )
         case (HSIMT) ! Wu and Zhu (2010, OCEMOD)
            kappa = 1 - cfl
            x = 0.25*( kappa - one3rd/kappa )
            limiter = (0.5+x) + (0.5-x)*ratio ! can become negative!!!
            limiter = MAX( 0.0_real64 , limiter )
            limiter = MIN( 2*ratio , limiter , 2.0_real64 )
         case (MUSCL)
            limiter = MIN( 2*ratio , 0.5*(1+ratio) , 2.0_real64 )
         case default
!           UPSTREAM
            limiter = 0
      end select

      adv_reconstruct = fu + 0.5*limiter*(1-cfl)*deltaf

   end if

   return
END FUNCTION adv_reconstruct
#endif
